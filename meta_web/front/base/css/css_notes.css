/* 
selector {
  property-one : value;
  property-two : value;
}
selector may be:
  - type selector
    HTML tag name (element)

  - class selector
    val of "class" attr for elem (.class-name)

  - id selector
    val of "id" attr for elem (#idName)
    ID is unique. It's prefered to use with JS
  
  - attribute selector
    has several syntax variations
      [attr], [attr=val], [attr~=val], [attr|=val], [attr^=val], [attr$=val], [attr*=val]

  - universal selectors *

  - combinational selectors
    - descendant selectors (parent child)
      useful if you need to select HTML elems contained within another selector
      The easiest way to remember is to think of a family
        pick a person in the family and select all descendants, such as children, grandchildren and great grandchildren

    - child selectors (parent > child)
      are more specific than descendant selectors
      in family ex, select a person and then select only their immediate children

      
    - general sibling selectors (selector ~ sibling)
      apply rules to all the selectors of the same type that follow the first type
      for family ex, select a person and then select all younger brothers

    - adjacent sibling selectors (selector + sibling)
      to target only the first or adj elem that follows another elem
      (only selects the first subseq elem if it matches the selector)
      for family ex, select a person and then selects the next younger brother
      
    Adj combinators will only target the first elem after the specified elems
    Sibling combinators target all elems of the same type that follow the specified elem

  - pseudo class selectors (selector:pseudo-class)
    improve the interactivity of web pages by styling elements in response to user input
    allow selecting elems based on their state
    
    user action states
      have an effect while a user is actively engaging with a HTML elem
      - "focus" focuses styling on the elem that you use it for
      - "visited" changes the style of link when a user visited it
      - "hover" changes the style of elem when a cursor hovers over it
      - "active" styles an elem only while a user actively presses and holds mouse btn
      LVHA: link visited hover active (to remind web-link states in order)
    
    form states
      usually come in pairs and target the diff states that elems can have
      "disabled" and "enabled" generally used for btns
      "checked" and "indeterminate" used for checkboxes
      "valid" and "invalid" used in case of fields like emails and phone nums
    
    specific position-based states
      allow you to target specific items
      ":first-of-type" style the first item of its type while remaining items won't be affected
      ":last-of-type" style the last item of its type while remaining items won't be affected
      ":nth-of-type()", ":nth-last-of-type()", ...

  - pseudo elements (selector::pseudo-element)
    help you style a specific part of an element
    "::first-letter" change style of just the first letter
    "::first-line" change style of the complete first line
    "::selection" its effect becomes obvious only after the user selects content
    "::marker" add style elements to a list, for instance, to color bullet points (enhancing ux)
    "::before" and "::after" allow adding content before and after an elem (without HTML code)

  - group selectors (selector1, selector2)
    sometimes called selector stacking

part inside {} is called decleration block
pseudo-class is very useful for creating visual effects based on user interaction
if the prop is repeated with another value for the same elem even if with a diff selector it overwrites the prev
*/

h1 {
  color: purple;
}

#first {
  color: green;
}

.second {
  background-color: black;
  color: white;
}

.parent h1 {
  margin: 2px;
}

.parent p span {
  background-color: blue;
}

p > span {
  color: black;
}

a:hover {
  color: orange;
}

/*
there are 5 main ways to reference a color:
  - RGB value
      rgb(intensity of red, intensity of green, intensity of blue)
      rgb(0:255, 0:255, 0:255)
      rgb(255, 0, 0) = red
      rgb(0, 255, 0) = green
      rgb(0, 0, 255) = blue
      rgb(0, 0, 0) = black
      rgb(255, 255, 0) = red + green = yellow
      rgb(255, 0, 255) = red + blue = Fuchsia
      rgb(0, 255, 255) = green + blue = aqua
      rgb(255, 255, 255) = white
      rgb(128, 128, 128) = gray
      if intensities of red = green = blue then it's an intensity of gray

  - RGBA value
      rgba(intensity of red, intensity of green, intensity of blue, transparency|opacity of the color)
      "a" refers to alpha channel
      rgb(0:255, 0:255, 0:255, 0:1)

  - HSL value
      to simplify mental visualization of the color that the val represents
      a newer color model defined as Hue (H), Saturation (S) and Lightness (L)
      a rainbow that has been turned into a full circle
        The Hue val is the deg val on this circle:
          - int num from 0 deg to 360 deg
          - if the number is not int it will be rounded
          - if the number exceeds 360 it will be subtracted to be in the range
          - 0 = 360 = red
          - 120 = green
          - 240 = blue
        Saturation is the dist from the center of the circle to its edge:
          - percentage from 0% to 100%
          -  0% is the center of the circle (color is more grey)
          - 100% is its edge (full color)
        Think of turning the circle into a 3D cylinder where its bottom is more black and toward the top is more white
        Lightness is the distance from the bottom of the cylinder to the top
          - percentage from 0% to 100%
          - 0% is the bottom of the cylinder (color is more black)
          - 100% is its top (color is more white)
      hsl(0:360, 0%:100%, 0%:100%)

  - hex value
      a different number set from 0 to 15 ( 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - A - B - C - D - E - F )
      Colors specified using hexadecimal are prefixed with a #
      #RRGGBB
        - every 2 digs are from 0x0 to 0xFF (0:255)
        - first 2 digs rep intensity of red
        - 2 middle digs rep intensity of green
        - last 2 digs rep intensity of blue
        - #FF0000 = #F00 = red
        - #00FF00 = #0F0 = green
        - #0000FF = #00F = blue
        - #000000 = #000 = black
        - #FFFF00 = #FF0 = red + green = yellow
        - #FF00FF = #F0F = red + blue = Fuchsia
        - #00FFFF = #0FF = green + blue = aqua
        - #FFFFFF = #FFF = white
        - #808080 = gray
      #(00:FF)(00:FF)(00:FF)
      #(0:FF)(0:F)(0:F)
      if every 2 digs has a repeated val u can write 3 digs only

  - predefined color names (names of colors)
*/

/* 
there are many ways to change how text is displayed:
  - Color (color: )
  - Font (font-family: )
    - Since computers vary in what fonts they have installed, it is recommended to include several fonts sep with ,
    - if the font name is 2+ words use it inside "" if a single word u have the choice to add "" around or not to
  - Size (font-size: )
    - num_value followed by unit like: px
  - Transformation (text-transformation: )
    - none (default value)
    - uppercase (all chars in text are capital form)
    - lowercase (all chars in text are small form)
    - capitalize (every first char in every word in the text in capital form)
  - Decoration (text-decoration: )
    - takes one of the 2 val formats
      - line;
      - line color style thickness;
    - or can be sep to 4 diff prop
      - line (text-decoration-line: )
        - line-through, overline, underline
      - color (text-decoration-color)
      - style (text-decoration-style)
        - solid (default), dotted, dashed, double, wavy
      - thickness (text-decoration-thickness)
        - num_value followed by unit like: px
    - without line all decoration props will not be styled
    - without line and thickness other decoration props will not styled even if they are declared
  - Alignment
    - left (default for ltr langs like: en)
    - right (default for rtl langs like: ar)
    - center
    - justify (spreads the text out so that every line of the text has the same width)
*/

h1 {
  width: 800px;
  padding-left: 20px;
  padding-left: 10px;
  border-left: 5px solid black;
  border-right: 7px dashed green;
  margin-left: 15px;
  margin-right: 20px;
  height: 70px;
  padding-top: 10px;
  padding-bottom: 10px;
  border-top: 2px dotted red;
  border-bottom-width: 3px;
  border-bottom-style: double;
  border-bottom-color: blue;
  margin-top: 15px;
  margin-bottom: 15px;
}

/*
Box Model
  main props
    width & height
      - num_val followed by unit like: (px)
      - percentage % of the parent elem
    padding:
      - top right bottom left; (4 vals)
      - top&bottom right&left; (2 vals)
      - top&right&bottom&left; (1 val)
    border:
      - width style color, width style color, width style color, width style color;
      - it's in CW direc, too
      - can be sep to 3 prop:
        - width (border-width: )
          - num_value followed by unit like: px
        - style (border-style: )
          - none (default), solid, dotted, dashed, double, wavy
        - color (border-color: )
    margin:
      - top right bottom left; (4 vals)
      - top&bottom right&left; (2 vals)
      - top&right&bottom&left; (1 val)

  width
    box width
                                                width
    padding box width
                                  padding-left + width + padding-right
    border box width
                    border-left + padding-left + width + padding-right + border-right
    margin box width
      margin-left + border-left + padding-left + width + padding-right + border-right + margin-right
  
  height
    box height
                                              height
    padding box height
                                padding-top + height + padding-bottom
    border box height 
                   border-top + padding-top + height + padding-bottom + border-bottom
    margin box height 
      margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom

  num_val followed by unit like: (px)
*/

/*
block and inline elems
  - block
    - are mainly: div form h p ...
    - appear on a new line
  - inline
    - are like: img a input label b i em span ...
    - Inline elements only occupy the width and height of their content
  - to change elems default we use display prop
    - display: inline;
    - display: block;
*/

/*
HTML Element Alignment
  Aligning an HTML elem is done by changing the properties of its box model and how it impacts the doc flow
  - margin: auto;
  or
  - margin-left: auto;
    margin-right: auto;
    - tells the browser to calc the horizontal margin automatically based on the space available.
    - works with block elem with width < its parent's width
      - if u want to use it with inline elems, turn it first to block by (display: block;)

  - float
    - sets an element's position relative to the text content within a parent elem, Text will wrap around the elem
    - works with inline elems or block elem with width < its parent's width
*/

input[required]:focus {
  border: none;
  outline: none;
  border: 2px dashed #777;
}

input[required]:invalid {
  border: 2px solid red;
}

input[required]:valid {
  border: 2px solid green;
}

/*
Form validation
for input elem selector apply a pseudo-class selector
  - invalid & valid
    the key thing to know is that they are used to select elems based on their state, 
    such as whether the input data is valid or invalid
    all form fields are empty when the form loads initially, their state is still practically invalid
    add CSS prop to set border of elem to red, 
    This will cause all form fields to display red from the start like in this Real-world ex of a login screen
  - focus
    you only want fields to appear red as the user enters invalid data
    checks if the user is currently entering data into this field
    apply another pseudo-class called "focus"
    Now the form will appear normal when the page first loads, 
    and when the user inputs data, the field will turn red if the data is invalid
*/

/*
styling form by CSS
  browsers handle forms diff but with CSS makes all browsers display the form in the same way
  styling of individual elems using selectors. It will display the same across browsers with consistent ux
*/


.layout {
  display: inline;
  display: block;
  display: flex;
  display: grid;

  flex-direction: row;
  flex-direction: column;
  
  justify-content: stretch;
  justify-content: center;
  justify-content: space-around;
  justify-content: space-between;
  justify-content: space-evenly;
  justify-content: flex-start;
  justify-content: flex-end;

  align-items: stretch;
  align-items: center;
  align-items: flex-start;
  align-items: flex-end;
  
  flex: 0 1 auto; /* flex-grow flex-shrink flex-basis */
}
/*
flexbox and grid
  They added more flexibility and D with better options for fine tuning specific sec of a web page
  The main diff btw the two is that
    
    "flexbox" is 1D
      The most common uses are creating a responsive search bar, nav bar, img gall and charts (like bar chart)
      is short for flexible box model and it was introduced before the grid layout
      
      adds responsiveness to CSS with float elems and positioning 1D ref that 
        a given flexbox container will arrange items in either col or row along its axis
      
      can flex to shrink or expand. Thus resulting in a flexible rwd

      "flex-direction"
      sets main axis
      "row" (default val) 
      "col" means changing main from horizontal rows to vertical cols
      
      "flex-wrap" 
      "nowrap" (default val) means the items will span the entire width of the axis
      "wrap" makes items wrapped to the size of the available viewport
      
      "flex-grow", "flex-shrink" and "flex-basis"
      "flex-grow" specifies how much item will grow compared to other flexible items
      "flex-shrink" specifies how much item will shrink compared to other flexible items
      "flex-basis" specifies the initial len of flexible item (initial size of the container)
      Together they define the rigidity or flexibility and dynamism you want to add to flexbox
        (determine how the flex takes up space, grows or shrinks according to the space available)
      Together can be given vals with the help of "shorthand notation" in CSS (code compact)
        vals left empty are given their default vals
        "flex" prop correspond to the 3 props as in above order (flex-grow flex-shrink flex-basis)
          To demonstrate the effect of this "flex-direction" val if set to "column" is to be removed

      has two axes: "main" and "cross-axis"
        When aligned along the "row", horizontal axis is "main" and vertical axis is "cross"
        For the items present inside the flexbox container
          the placement starts from the top-left corner moving along the main or horizontal axis
          When the row is filled, the items continue to the next row
        When aligned along the "column", you flip "main" to run vertically and "cross" will be horizontal
          items will start from top left and move down along the vertical main axis
      
      - props you choose will help control alignment, spacing, direc and styling container and items inside it
    
    "grid" is 2D (as the word implies)
      is similar to the flexbox except it creates 2D grid along both the row and col axes
      for creating complex page layout it's prefered to use grid sys, rel units and media queries rather than flexbox
      The best way to ensure uniformity of rows and cols is to use "auto" and the "repeat" func together
      Two such grid design layouts 12 and 16-col grids divide the page into 12 and 16 tracks along the vertical cols
      
      these are the steps in general to use grid sys:
        - Define the grid using display property
        - Set the height and width of the grid
        - Set the grid-template-areas with the appropriate name identifiers
        - Add the appropriate sizes for the rows inside the grid using grid-template-rows property
        - Add the appropriate sizes for the columns inside the grid using grid-template-columns property
        names used inside "grid-template-areas" are the HTML tags 
        or where you need to get more specific, you designate a class name to these tags

    alignment props
      - "justify-content" For item alignment on main axis
      - "align-items" For item alignment on cross axis
      - "align-self" For unique flex items on cross axis
      - "align-content" Used for packing flex lines and control over space
      "justify-content" and "align-items" are freq used for the respective 2 axes
    
    "gap" (gutter)
      used to create space btw items along "main"
      You can also individually config gaps in rows and cols using "row-gap" and "column-gap" props

    flexboxes are more suitable when you want to create flexible elements in smaller spaces
    grids are more suitable to large-scale layouts
*/


/*
CSS Units
are used to account for the dynamism and dimensionality of a web page
  - Absolute units
    constant across different devices and have a fixed size
    are used when the size of the web page is known and will remain const (useful for act like printing a page)
    are not so suitable when it comes to the wide variety of devices have diff viewport sizes
    "px" and "cm" are most freq used

  - Relative values
    are def in rel to
      - viewport or the size of the visible web page
      - other elements present inside the parent element
    many are used in terms of the rel size of fonts. Some are more suitable depending on the rel context
      when the Ds of the viewport are imp, it's more appropriate to use "vw" and "vh"
      In a broader context, rel units most freq used are "%", "em", "vh", "vw" and "rem"

certain props have their own set of accept vals that need to be taken into account
  For ex, "background-color" will have vals such as #RRGGBB, rgb(), rgba(), hsl(), hsla() and so on
*/

/*
Specificity is ranking or score helps CSS determine the final rule will be applied to a given elem
CSS engines use specificity to resolve conflicts (elem with the highest specificity is selected by CSS)

CSS has a set of rules that it uses to score or assign a certain weight to selecs and creates a specificity hierarchy.
these rules only apply in cases where conflicts arise for the props
Based on the weights, there are 4 cats in this hierarchy:
  - Inline styles
    are attached to the elems within your HTML code like with "style" attr
    have the highest specificity (will be applied irrespective of other rules)

  - IDs
  
  - Classes, attributes, and pseudo-classes
  
  - Elements and pseudo-elements
    have the lowest pos in the specificity hierarchy

CSS uses the hierarchical model internally to calculate the specificity of the selectors used on a web page
as the size of CSS code increases, devs unavoidably face rule conflicts
so they use specificity hierarchy to calc the precedence of CSS rules and control the outcome of their web pages
While the weights assigned from hierarchical struct help in a systematic approach, 
there are a few more imp guidelines and rules in cases when score for diff selecs is the same
Some of these are:
  Every selector will have a score and place in the hierarchy
  In the case of selectors with equal specificity, the latest or last written rule is the one that will be applied
  In general, ID selector should be applied in cases where you need to be certain about a rule 
  Universal selectors have zero specificity value
*/

.effect {
  color: white;
  background-color: black;
  transition: 1s;
}

.effect:hover {
  transform: rotateZ(60deg);
}

.animated {
  animation: animation-name-2 1s infinite ease;
}

@keyframes animation-name {
  0% {transform: rotate(100deg);}
  30% {opacity: 1;}
  50% {opacity: 0.50;}
  70% {opacity: 1;}
  100% {transform: rotate(50deg);}
}

.not-animated { /* sub props and default vals */
  animation-name: none;
  animation-duration: 0s;
  animation-timing-function: ease;
  animation-delay: 0s;
  animation-iteration-count: 1;
  animation-direction: normal;
  animation-fill-mode: none;
  animation-play-state: running;
  animation-timeline: auto;
}
/*
CSS effects
  "transition"
  ":hover"
  "transform:"

  "animation"
  "@keyframes {}" to control the execution of the steps of the animation they use the at-keyframe rule

animation is shorthand for sub props (with default vals)
  default timing func is "ease" and that will cause an animation to be 
    slow at the start, speed up in the middleand slow down at the end again
  To make an animation move at a consistent speed you should change it from "ease" to "linear"

to make your animations more complex and exciting, you need to have good control over the timing

At-rules are statements inside CSS that describe how to behave or perform certain actions
*/

/*
CSS Preprocessors

  special compilers used to create CSS file that can be ref by HTML doc (extension of CSS)
    reduce the amount of CSS you need to write and allow you to re-use vals across multiple rules
    make re-using animations and effects much easier (not just in animation but any CSS code)

  Some feats of preprocessors have option to create vars, loops, and "if else" states
  
  Diff preprocessors have their own syntax and configs for adding feats
  
  use of preprocessors req i of a compiler on top of your web server
  
  In the early days of CSS, the main problem devs faced was the difficulty of managing the code.
  The way CSS was designed made the code very long, messy and complex. It also made it difficult to troubleshoot
  Preprocessors have their own scripting lang that adds logical structs, auto props, reusability and bloating of code
  
  most commonly used preprocessors: SASS, LESS, Stylus and PostCSS
    - SASS and SCSS
    SASS is a scripting lang that CSS compiles and interprets into CSS.
    SCSS is the syntax for SASS and can be seen as an advanced v of both SASS and CSS
    There are 2 syntaxes available for SASS
      
      - first known as SCSS (Sassy CSS)
        is an ext of the syntax of CSS means that every valid CSS stylesheet is a valid SCSS file with the same meaning
        This syntax is enhanced with the SASS feats. Files using this syntax have the ".scss" extension
      
      - second kown as the indented syntax (or just "SASS")
        is the older syntax provides a more concise way of writing CSS.
        Files using this syntax have the .sass extension
        uses
          indentation rather than brackets to indicate nesting of selectors
          newlines rather than ";" to separate props
      
    allow usage of math and other funcs that can be utilized for adding rules conditionally

    Another important funct in SASS is the use of directives
      - "@mixin", "@include"
        add properties that you want to reuse inside "@mixin"
        use "@include" and add the mixin identifier that you have created using the "@mixin" directive
      - "@import" and "@extend"
        "@import" allows the import of rules from another file,
        "@extend" allows all the rules from a specific selector to be added inside another selector

    - Stylus CSS
    It is not hard to miss the simplicity of the code without the colons, brackets or semicolons.
    But it is still allowed to use all of them in Stylus without any error
    allow the use of funcs useful when adding color gradation or creating advanced geo shapes on web page
*/

/*
CSS errs and linters
  CSS does not handle errs. It passes through code and ignores lines doesn't understand
  VSCode will indicate general errs
  linter can help you find any problematic patterns or inefficiencies in code (run tests on CSS code)
*/

/*
CSS Debugging
  CSS compiler reads the elements from right to left
  styling you have renders correctly in the IDE but misbehaves in a browser
    as they have their own default CSS stylesheets called "user-agent" styles
    Overriding the browser's settings can be done with universal selector
      props such as "margin: 0px;" to reset the margin vals set by browser by default
*/

